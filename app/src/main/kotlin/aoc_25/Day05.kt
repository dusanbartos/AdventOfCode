/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package aoc_25

import aoc_24.getResourceAsStringCollection
import kotlin.math.max
import kotlin.math.min

class Day05 {

    fun part1() {
        println("=== Part 1 ===")
        val testInput = getResourceAsStringCollection("2025/day05_test.txt")
        val testResult = getPart1(testInput)
        println("test result - $testResult")
        if (testResult != 3L) throw Exception("example 1 not passing")

        val input = getResourceAsStringCollection("2025/day05_input.txt")
        val result = getPart1(input)
        println("result - $result")
    }

    fun part2() {
        println("=== Part 2 ===")
        val testInput = getResourceAsStringCollection("2025/day05_test.txt")
        val testResult = getPart2(testInput)
        println("test result - $testResult")
        if (testResult != 14L) throw Exception("example 2 not passing")

        val input = getResourceAsStringCollection("2025/day05_input.txt")
        val result = getPart2(input)
        println("result - $result")
    }

    private fun getPart1(input: List<String>): Long {
        var result = 0L

        // process fresh ranges
        val freshSet = mutableSetOf<LongRange>()
        input.takeWhile { it.isNotEmpty() }.forEach { line ->
            line.split("-").let {
                freshSet.add(it[0].toLong()..it[1].toLong())
            }
        }

        input
            .dropWhile { it.isEmpty() || it.contains("-") }
            .map { it.toLong() }
            .forEach { iid -> if (freshSet.any { iid in it }) result++ }

        return result
    }

    private fun getPart2(input: List<String>): Long {
        // process fresh ranges
        val freshSet = mutableSetOf<LongRange>()
        input.takeWhile { it.isNotEmpty() }.forEach { line ->
            line.split("-").let {
                freshSet.add(it[0].toLong()..it[1].toLong())
            }
        }

        val merged = mergeRanges(freshSet)
        // long overflow when using [LongRange.count()]
//        return merged.sumOf { it.count() }.toLong()
        return merged.sumOf { it.last - it.first + 1 }
    }

    private fun mergeRanges(input: Set<LongRange>): Set<LongRange> {
        val result = mutableSetOf<LongRange>()
        input.forEach { range ->
            val matchingRanges = result.filter { range.first <= it.last && range.last >= it.first }
            if (matchingRanges.isNotEmpty()) {
                result.removeAll(matchingRanges.toSet())
                val newRange = min(range.first, matchingRanges.minOf { it.first })..max(range.last, matchingRanges.maxOf { it.last })
                result.add(newRange)
            } else {
                result.add(range)
            }
        }
        return result
    }
}

fun main() {
    Day05().apply {
        part1()
        part2()
    }
}
