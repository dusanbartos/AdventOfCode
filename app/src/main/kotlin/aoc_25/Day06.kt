/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package aoc_25

import aoc_24.getResourceAsStringCollection

class Day06 {

    fun part1() {
        println("=== Part 1 ===")
        val testInput = getResourceAsStringCollection("2025/day06_test.txt")
        val testResult = getPart1(testInput)
        println("test result - $testResult")
        if (testResult != 4277556L) throw Exception("example 1 not passing")

        val input = getResourceAsStringCollection("2025/day06_input.txt")
        val result = getPart1(input)
        println("result - $result")
    }

    fun part2() {
        println("=== Part 2 ===")
        val testInput = getResourceAsStringCollection("2025/day06_test.txt")
        val testResult = getPart2(testInput)
        println("test result - $testResult")
        if (testResult != 3263827L) throw Exception("example 2 not passing")

        val input = getResourceAsStringCollection("2025/day06_input.txt")
        val result = getPart2(input)
        println("result - $result")
    }

    private fun getPart1(input: List<String>): Long {
        var result = 0L

        var index = 0
        var problem = input.solveProblemAt(index)
        while (problem != null) {
            result += problem
            index++
            problem = input.solveProblemAt(index)
        }

        return result
    }

    private val separatorRegex = "\\s+".toRegex()

    private fun List<String>.solveProblemAt(index: Int): Long? {
        val operation = this.last().explode().getOrNull(index)?.first()
        if (operation == null) return null

        var solution = if (operation == '+') 0L else 1L
        this.dropLast(1).forEach { line ->
            line.explode().get(index).let { num ->
                if (operation == '+') {
                    solution += num.toLong()
                } else {
                    solution *= num.toLong()
                }
            }
        }
        return solution
    }

    private fun String.explode(): List<String> =
        this.split(separatorRegex).filter { it.isNotEmpty() }

    private fun getPart2(input: List<String>): Long {
        val indices = input.maxOf { it.length }

        var result = 0L
        var temp = 0L
        var lastOperation: Char? = null

        (0..<indices).forEach { index ->
            val operation = input.last().getOrNull(index)?.takeIf { it != ' ' }
            if (operation != null) {
                // save temp and reset
                lastOperation = operation
                temp = if (operation == '+') 0L else 1L
            }

            val number = input.dropLast(1)
                .mapNotNull { line -> line.getOrNull(index).takeIf { it != ' ' } }
                .takeIf { it.isNotEmpty() }
                ?.joinToString("")
                ?.toLong()
            if (number != null) {
                if (lastOperation == '+') {
                    temp += number
                } else {
                    temp *= number
                }
            } else {
                // save result, all columns empty
                result += temp
            }
        }

        // save result, end
        result += temp

        return result
    }
}

fun main() {
    Day06().apply {
        part1()
        part2()
    }
}
